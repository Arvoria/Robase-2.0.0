{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robase Site in progress This website is still a work in progress and changes are being made daily. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here . Why Robase? Robase was developed to solve a few problem areas of DataStores Storing large amounts of data (>4MB) is impossible without using external databases DataStores are only accessible at one point, Robase can access any key no matter how deeply nested it may be and get or update it's data (Explained later on). Easily extensible and wrappable and should allow for \"managers\" to be easily made for your data. Thanks to Promises you can be sure each async function yields and returns a value, thus no worry over race conditions. Storing a large amount of data If you're developing a game on Roblox it is very likely you have encountered DataStoreService and you may have even used ProfileService or DataStore2 for easier management of your data. You will also likely be saving simple player data: how much money they have; which missions they have completed; what buffs they may have from Gamepasses or Developer Products; etc. However, there could come a point where a player's data could exceed the 4MB limitation of DataStores, this would result in the partial loss of the data. It is unlikely you will reach this limitation if you are only looking to store simple data, Robase, however, is best used if you're looking to store more complex data: exact inventory content; several different skill tree buffs; a list of missions and their completion steps with completed steps flagged as such. Firebase has a free plan ( Spark ) which limits you to: 1GB Storage capacity 10GB of downloads (Get requests) per month# However, the \"pay as you go\" plan ( Blaze ) is enticing with: Storage costs $5/GB/mo (Storing 2GB = $10/month) Downloaded data costs $1/GB/mo (100GB downloaded in a month = $100) Accessing deeply-nested keys Being able to directly access a deeply-nested key is extremely helpful, not only is it simple to do, it also saves on downloading an entire key, quite possibly, for multiple ocassions. As an example, we will use the following data structure: local Profile = { Inventory = { _metadata = { _currentPage = 1, _isFull = false, _totalCapacity = 32, _numItems = 0, } Pages = { [1] = { Slots = { [1] = {--[[Item Data]]}, [2] = {--[[Item Data]]}, [3] = {--[[Item Data]]}, [4] = {--[[Item Data]]}, [5] = {--[[Item Data]]}, [6] = {--[[Item Data]]}, [7] = {--[[Item Data]]}, [8] = {--[[Item Data]]}, } }, ... } }, Skills = { [\"Woodcutting\"] = { Title = \"Woodcutting\", Aliases = { }, Level = 5, Description = \"Speeds up woodcutting\", }, ... } Missions = { InProgress = { [\"QuestId\"] = { Stage = \"some stage Id\", }, ... }, Completed = { \"QuestId\", \"QuestId2\", ... } } } Accessing and navigating this data structure, which could expand even further than it does, could be very daunting. First you would need to get the data at the base key, then you would need to assign a variable to point to a given key in this data structure ( Data.Missions.Completed for example), and then you could access it. However, with Robase and Firebase, you could perform a single GetAsync request to \"{Data}/Missions/Completed\" where {Data} is the top-level key to access a Player's data. No longer do you need to perform sanity checks to see if the data exists or not, if it's not in the database Robase will tell you that and what specifically went wrong! If this data is non-existent, then you can create or do something about it.","title":"Robase"},{"location":"#robase","text":"Site in progress This website is still a work in progress and changes are being made daily. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here .","title":"Robase"},{"location":"#why-robase","text":"Robase was developed to solve a few problem areas of DataStores Storing large amounts of data (>4MB) is impossible without using external databases DataStores are only accessible at one point, Robase can access any key no matter how deeply nested it may be and get or update it's data (Explained later on). Easily extensible and wrappable and should allow for \"managers\" to be easily made for your data. Thanks to Promises you can be sure each async function yields and returns a value, thus no worry over race conditions.","title":"Why Robase?"},{"location":"#storing-a-large-amount-of-data","text":"If you're developing a game on Roblox it is very likely you have encountered DataStoreService and you may have even used ProfileService or DataStore2 for easier management of your data. You will also likely be saving simple player data: how much money they have; which missions they have completed; what buffs they may have from Gamepasses or Developer Products; etc. However, there could come a point where a player's data could exceed the 4MB limitation of DataStores, this would result in the partial loss of the data. It is unlikely you will reach this limitation if you are only looking to store simple data, Robase, however, is best used if you're looking to store more complex data: exact inventory content; several different skill tree buffs; a list of missions and their completion steps with completed steps flagged as such. Firebase has a free plan ( Spark ) which limits you to: 1GB Storage capacity 10GB of downloads (Get requests) per month# However, the \"pay as you go\" plan ( Blaze ) is enticing with: Storage costs $5/GB/mo (Storing 2GB = $10/month) Downloaded data costs $1/GB/mo (100GB downloaded in a month = $100)","title":"Storing a large amount of data"},{"location":"#accessing-deeply-nested-keys","text":"Being able to directly access a deeply-nested key is extremely helpful, not only is it simple to do, it also saves on downloading an entire key, quite possibly, for multiple ocassions. As an example, we will use the following data structure: local Profile = { Inventory = { _metadata = { _currentPage = 1, _isFull = false, _totalCapacity = 32, _numItems = 0, } Pages = { [1] = { Slots = { [1] = {--[[Item Data]]}, [2] = {--[[Item Data]]}, [3] = {--[[Item Data]]}, [4] = {--[[Item Data]]}, [5] = {--[[Item Data]]}, [6] = {--[[Item Data]]}, [7] = {--[[Item Data]]}, [8] = {--[[Item Data]]}, } }, ... } }, Skills = { [\"Woodcutting\"] = { Title = \"Woodcutting\", Aliases = { }, Level = 5, Description = \"Speeds up woodcutting\", }, ... } Missions = { InProgress = { [\"QuestId\"] = { Stage = \"some stage Id\", }, ... }, Completed = { \"QuestId\", \"QuestId2\", ... } } } Accessing and navigating this data structure, which could expand even further than it does, could be very daunting. First you would need to get the data at the base key, then you would need to assign a variable to point to a given key in this data structure ( Data.Missions.Completed for example), and then you could access it. However, with Robase and Firebase, you could perform a single GetAsync request to \"{Data}/Missions/Completed\" where {Data} is the top-level key to access a Player's data. No longer do you need to perform sanity checks to see if the data exists or not, if it's not in the database Robase will tell you that and what specifically went wrong! If this data is non-existent, then you can create or do something about it.","title":"Accessing deeply-nested keys"},{"location":"introduction/","text":"Introduction Robase (formerly: Roblox-Firebase) has been in development since Summer 2020 and has been released since Early-Fall 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever. What's the purpose? Unfortunately, DataStores have issues: You cannot look at the source code directly, meaning you have to trust the documentation; You are limited to 4MB of data per key You can only access top-level keys ( Player.UserId s) and must define a path to a given point with table notation. ( table.this.that ). Exposing the internals of the API allow Robase to be easily extended upon and wrapped around to create a \"manager\" for your database; similar to the ProfileService or DataStore2 modules. Promises ensure race safety. Every async function will yield until a value is retrieved. Cannot be updated dynamically, from anywhere, at anytime. This makes systems such as FFlags not possible, A/B Testing extraneous, and timed-events that can turn on at a moment's notice in a live game - impossible. Trusting Documentation More often than not you can trust what the documentation says, \"it will do X\", generally means it will \"do X\". However, there comes a time where you want to know \"how does it 'do X'\" and that can only be solved in two manners: You dive into the source code Or, you can see if the docs tell you And unfortunately, Roblox doesn't provide extensive documentation on every single method and every single service, this would be a massive task. Source Docs - documentation within source code - are an amazing resource to use to help developers stay sane when looking at your codebase. Thankfully, Robase has this technical project documentation page and source docs! Storage limitations Before using Robase something you may want to ask yourself is: Do I really need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Developing a game on Roblox means that you will have used one of the following: DataStoreService , DataStore2, or ProfileService; the latter two of which being wrappers/managers for the former. This informs me that you are currently saving simple player data: number of coins, stats and levels, minor inventory data, etc. Accessing deeply-nested keys Being able to access a deeply-nested key can be helpful for a few reasons: It can save on HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Saves on sanity checks: if table.that.this then end As an example, we will use the following data structure: local PlayerProfile = { Stats = { } Inventory = { Pages = { } _metadata = { _totalSlots = 8, _totalPages = 1, } }, InAppPurchases = { [\"GamepassId\"] = { PurchasedOn = \"1/1/1970 00:00 UTC\", } }, _metadata = { _playTime = 0, _lastSessionDuration = 0, _currentSessionDuration = 0, _totalLevel = 10, _sessionLastLocked = \"1/1/1970 00:00 UTC\", _sessionLocked = true, _lastAutoSave = \"1/1/1970 00:00 UTC\", _lastManualSave = \"1/1/1970 00:00 UTC\", } }","title":"Introduction"},{"location":"introduction/#introduction","text":"Robase (formerly: Roblox-Firebase) has been in development since Summer 2020 and has been released since Early-Fall 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever.","title":"Introduction"},{"location":"introduction/#whats-the-purpose","text":"Unfortunately, DataStores have issues: You cannot look at the source code directly, meaning you have to trust the documentation; You are limited to 4MB of data per key You can only access top-level keys ( Player.UserId s) and must define a path to a given point with table notation. ( table.this.that ). Exposing the internals of the API allow Robase to be easily extended upon and wrapped around to create a \"manager\" for your database; similar to the ProfileService or DataStore2 modules. Promises ensure race safety. Every async function will yield until a value is retrieved. Cannot be updated dynamically, from anywhere, at anytime. This makes systems such as FFlags not possible, A/B Testing extraneous, and timed-events that can turn on at a moment's notice in a live game - impossible.","title":"What's the purpose?"},{"location":"introduction/#trusting-documentation","text":"More often than not you can trust what the documentation says, \"it will do X\", generally means it will \"do X\". However, there comes a time where you want to know \"how does it 'do X'\" and that can only be solved in two manners: You dive into the source code Or, you can see if the docs tell you And unfortunately, Roblox doesn't provide extensive documentation on every single method and every single service, this would be a massive task. Source Docs - documentation within source code - are an amazing resource to use to help developers stay sane when looking at your codebase. Thankfully, Robase has this technical project documentation page and source docs!","title":"Trusting Documentation"},{"location":"introduction/#storage-limitations","text":"Before using Robase something you may want to ask yourself is: Do I really need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Developing a game on Roblox means that you will have used one of the following: DataStoreService , DataStore2, or ProfileService; the latter two of which being wrappers/managers for the former. This informs me that you are currently saving simple player data: number of coins, stats and levels, minor inventory data, etc.","title":"Storage limitations"},{"location":"introduction/#accessing-deeply-nested-keys","text":"Being able to access a deeply-nested key can be helpful for a few reasons: It can save on HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Saves on sanity checks: if table.that.this then end As an example, we will use the following data structure: local PlayerProfile = { Stats = { } Inventory = { Pages = { } _metadata = { _totalSlots = 8, _totalPages = 1, } }, InAppPurchases = { [\"GamepassId\"] = { PurchasedOn = \"1/1/1970 00:00 UTC\", } }, _metadata = { _playTime = 0, _lastSessionDuration = 0, _currentSessionDuration = 0, _totalLevel = 10, _sessionLastLocked = \"1/1/1970 00:00 UTC\", _sessionLocked = true, _lastAutoSave = \"1/1/1970 00:00 UTC\", _lastManualSave = \"1/1/1970 00:00 UTC\", } }","title":"Accessing deeply-nested keys"}]}