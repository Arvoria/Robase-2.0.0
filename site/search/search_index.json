{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robase Site in progress This website is still a work in progress and changes are being made nightly. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use Luau wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here . Todo Update the Github Releases page for Robase 2.0.0-beta to include the new Set and Get promise returning methods. Fix 'removed' text in the introduction page for the new Set/Get methods. Change 'updated daily' to 'updated nightly' on the Home page. Add Source Documentation to Robase 2.0.0-beta using the LDoc convention. Use Definition Lists to define functions and their parameters","title":"Home"},{"location":"#robase","text":"Site in progress This website is still a work in progress and changes are being made nightly. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use Luau wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here . Todo Update the Github Releases page for Robase 2.0.0-beta to include the new Set and Get promise returning methods. Fix 'removed' text in the introduction page for the new Set/Get methods. Change 'updated daily' to 'updated nightly' on the Home page. Add Source Documentation to Robase 2.0.0-beta using the LDoc convention. Use Definition Lists to define functions and their parameters","title":"Robase"},{"location":"api/","text":"API Reference Warning This page is still in the process of being documented. RobaseService Caution RobaseService cannot be used without first instantiating it with .new and providing a Firebase Database Url and a Secrets Authentication Token. RobaseService.new Used to instantiate a new RobaseService with the provided Url and Auth Token. RobaseService.new(baseUrl: string, token: string) --> RobaseService This method will create a new RobaseService for the provided database. baseUrl: string This is the URL of your database, it can be found at the top of the database view in the Firebase Console. token: string This is your Database Secrets Authentication Token. Currently, RobaseService only accepts this method of authentication. RobaseService:GetRobase Used to retrieve a Robase object with a path supplied from scope and name. RobaseService:GetRobase([name: string, [scope: string]]) --> Robase This method will create a new Robase object at the path determined by scope and name. name?: string Optional (but recommended) parameter for the name of the key you wish to locate the Robase object from. scope?: string Optional parameter for the scope (directory depth) you wish to start searching for \"name\". This should be a path going through your database with keys separated by \"/\". Robase Caution Robase will handle failed requests automatically by throwing an error. They will never return (false, any) but they can return (true, nil) , for this reason, it is recommended to wrap your method calls with a pcall . Promise-returing methods Promise returning methods allow you to abstract over the original async methods of Robase so that you can implement custom functionality. This requires knowledge of Promises to implement and even further knowledge on them to perform meaningful tasks that Robase does not. These are retrieved synchronously but consumed asynchronously. Get Returns a promise associated with retrieving a value from the database. Robase:Get(key: string) --> Promise Returns a promise synchronously for an asynchronous get operation. key: string The name of the key you wish to retrieve data from. Set Returns a promise associated with adding a value into the database. Robase:Set(key: string, data: any [, method: string]) --> Promise Returns a promise synchronously for an asynchronous set operation. key: string The name of the key you wish to add data into (will create a new key if one does not exist). data: any The data you wish to add to the database method?: string Optional parameter defining the HTTP Method to use, this will default to \"PUT\". Async methods returning values The asynchronous methods of Robase are here to immediately retrieve information and perform operations on your database. These are simple and have no side effects outside of the HTTP Requests they perform. These are useful if you don't wish to do anything on top of what Robase already does and just wish to use the core functions. Internally, Robase uses the Promise-returning methods and consumes them with an :await() call. Robase:GetAsync Retrieves the data stored at the given key within the Robase. Robase:GetAsync(key: string) --> Success: Boolean, Result: any Retrieves data from the database from the given key. key: string The name of the key you wish to retrieve data from. Robase:SetAsync Adds data into the Robase at the key specified using the given method. Robase:SetAsync(key: string, data: any, [method: string]) --> Success: Boolean, Result: any Adds data into the Robase at the key specified using the given method if provided, or \"PUT\" otherwise. key: string The name of the key you wish to add data into (will create a new key if one does not exist). data: any The data you wish to put into the database. method?: string Optional parameter defining the HTTP Method to use, this will default to \"PUT\". Robase:IncrementAsync Increments the data stored at the given key by the supplied delta. This only works on key's which have an integer value and with an integer-only delta (ex. 1.5 will not work) Delta is an optional parameter and will default to 1 if not supplied. Robase:IncrementAsync(key: string, [delta: integer]) --> Success: Boolean, Result: any This method will increment an integer-typed value belong to the given key by either 1 or delta key: string The key you wish to increment delta?: integer An optional parameter for how much you wish to increment by, will default to 1 This parameter must be an integer, it can not be a number (5.7 for example). Usage restrictions You can only use ::IncrementAsync on keys with integer values! Delta must be an integer or nil! Robase:DeleteAsync Robase:DeleteAsync(key: string) --> Success: Boolean, Result: any This method will delete a key entirely from the database and returns the previously stored value. key: string The key you wish to delete from the database Dangerous This method is incredibly dangerous. It can delete entire trees of data and cannot be rolled back. It will return the data previously stored at the key given. Robase:UpdateAsync Retrieves data from the Robase at the given key, or from the cache if provided and transforms it using the callback function and updates the key with a new value. Robase:UpdateAsync(key, callback [, cache]) This method will take a key and modify its data using the callback ('updater') function. Optionally, it can take in a cache table whose contents match that of the key you are updating. key: string This is the key you are trying to modify the data of, it must be a table. callback: function(oldData) This is the function used to update (or modify) the data within the key. cache?: {[string]=table,...} Optional parameter used to provide Robase with data that should be newer than what the database has stored. Though it is strongly suggested that you update your database before updating your cache, else you risk losing data if your game crashes before the server can update the database with the cache. Robase:BatchUpdateAsync Similar in functionality to :UpdateAsync except given a baseKey, it will modify keys with the provided updater (callback) functions. Robase:BatchUpdateAsync(baseKey, callbacks [, cache]) This method takes in a baseKey and a table of callback ('updater') functions whose key's are children of the 'baseKey'. Optionally, it can take in a cache table whose keys match the callbacks table and should be the point of which baseKey starts in your database. baseKey: string This is the parent key of the keys you are trying to update, see the usage guide for more information. callbacks: {[string]=function(oldData),...} A dictionary of string-keys and function-values, the keys of this table should be the same name as the keys you wish to modify within the 'baseKey' of your database. These functions take a single parameter oldData and should return a table of modified data. This parameter is retrieved internally either from cache [ key ] where key is a key from callbacks , or it will be equal to a : GetAsync ( key ) request if a cache is not provided. cache?: {[string]=table]} Optional parameter used to provide Robase with data that should be newer than what the database has stored. Though it is strongly suggested that you update your database before updating your cache, else you risk losing data if your game crashes before the server can update the database with the cache.","title":"API Reference"},{"location":"api/#api-reference","text":"Warning This page is still in the process of being documented.","title":"API Reference"},{"location":"api/#robaseservice","text":"Caution RobaseService cannot be used without first instantiating it with .new and providing a Firebase Database Url and a Secrets Authentication Token.","title":"RobaseService"},{"location":"api/#robaseservicenew","text":"Used to instantiate a new RobaseService with the provided Url and Auth Token. RobaseService.new(baseUrl: string, token: string) --> RobaseService This method will create a new RobaseService for the provided database. baseUrl: string This is the URL of your database, it can be found at the top of the database view in the Firebase Console. token: string This is your Database Secrets Authentication Token. Currently, RobaseService only accepts this method of authentication.","title":"RobaseService.new"},{"location":"api/#robaseservicegetrobase","text":"Used to retrieve a Robase object with a path supplied from scope and name. RobaseService:GetRobase([name: string, [scope: string]]) --> Robase This method will create a new Robase object at the path determined by scope and name. name?: string Optional (but recommended) parameter for the name of the key you wish to locate the Robase object from. scope?: string Optional parameter for the scope (directory depth) you wish to start searching for \"name\". This should be a path going through your database with keys separated by \"/\".","title":"RobaseService:GetRobase"},{"location":"api/#robase","text":"Caution Robase will handle failed requests automatically by throwing an error. They will never return (false, any) but they can return (true, nil) , for this reason, it is recommended to wrap your method calls with a pcall .","title":"Robase"},{"location":"api/#promise-returing-methods","text":"Promise returning methods allow you to abstract over the original async methods of Robase so that you can implement custom functionality. This requires knowledge of Promises to implement and even further knowledge on them to perform meaningful tasks that Robase does not. These are retrieved synchronously but consumed asynchronously.","title":"Promise-returing methods"},{"location":"api/#get","text":"Returns a promise associated with retrieving a value from the database. Robase:Get(key: string) --> Promise Returns a promise synchronously for an asynchronous get operation. key: string The name of the key you wish to retrieve data from.","title":"Get"},{"location":"api/#set","text":"Returns a promise associated with adding a value into the database. Robase:Set(key: string, data: any [, method: string]) --> Promise Returns a promise synchronously for an asynchronous set operation. key: string The name of the key you wish to add data into (will create a new key if one does not exist). data: any The data you wish to add to the database method?: string Optional parameter defining the HTTP Method to use, this will default to \"PUT\".","title":"Set"},{"location":"api/#async-methods-returning-values","text":"The asynchronous methods of Robase are here to immediately retrieve information and perform operations on your database. These are simple and have no side effects outside of the HTTP Requests they perform. These are useful if you don't wish to do anything on top of what Robase already does and just wish to use the core functions. Internally, Robase uses the Promise-returning methods and consumes them with an :await() call.","title":"Async methods returning values"},{"location":"api/#robasegetasync","text":"Retrieves the data stored at the given key within the Robase. Robase:GetAsync(key: string) --> Success: Boolean, Result: any Retrieves data from the database from the given key. key: string The name of the key you wish to retrieve data from.","title":"Robase:GetAsync"},{"location":"api/#robasesetasync","text":"Adds data into the Robase at the key specified using the given method. Robase:SetAsync(key: string, data: any, [method: string]) --> Success: Boolean, Result: any Adds data into the Robase at the key specified using the given method if provided, or \"PUT\" otherwise. key: string The name of the key you wish to add data into (will create a new key if one does not exist). data: any The data you wish to put into the database. method?: string Optional parameter defining the HTTP Method to use, this will default to \"PUT\".","title":"Robase:SetAsync"},{"location":"api/#robaseincrementasync","text":"Increments the data stored at the given key by the supplied delta. This only works on key's which have an integer value and with an integer-only delta (ex. 1.5 will not work) Delta is an optional parameter and will default to 1 if not supplied. Robase:IncrementAsync(key: string, [delta: integer]) --> Success: Boolean, Result: any This method will increment an integer-typed value belong to the given key by either 1 or delta key: string The key you wish to increment delta?: integer An optional parameter for how much you wish to increment by, will default to 1 This parameter must be an integer, it can not be a number (5.7 for example). Usage restrictions You can only use ::IncrementAsync on keys with integer values! Delta must be an integer or nil!","title":"Robase:IncrementAsync"},{"location":"api/#robasedeleteasync","text":"Robase:DeleteAsync(key: string) --> Success: Boolean, Result: any This method will delete a key entirely from the database and returns the previously stored value. key: string The key you wish to delete from the database Dangerous This method is incredibly dangerous. It can delete entire trees of data and cannot be rolled back. It will return the data previously stored at the key given.","title":"Robase:DeleteAsync"},{"location":"api/#robaseupdateasync","text":"Retrieves data from the Robase at the given key, or from the cache if provided and transforms it using the callback function and updates the key with a new value. Robase:UpdateAsync(key, callback [, cache]) This method will take a key and modify its data using the callback ('updater') function. Optionally, it can take in a cache table whose contents match that of the key you are updating. key: string This is the key you are trying to modify the data of, it must be a table. callback: function(oldData) This is the function used to update (or modify) the data within the key. cache?: {[string]=table,...} Optional parameter used to provide Robase with data that should be newer than what the database has stored. Though it is strongly suggested that you update your database before updating your cache, else you risk losing data if your game crashes before the server can update the database with the cache.","title":"Robase:UpdateAsync"},{"location":"api/#robasebatchupdateasync","text":"Similar in functionality to :UpdateAsync except given a baseKey, it will modify keys with the provided updater (callback) functions. Robase:BatchUpdateAsync(baseKey, callbacks [, cache]) This method takes in a baseKey and a table of callback ('updater') functions whose key's are children of the 'baseKey'. Optionally, it can take in a cache table whose keys match the callbacks table and should be the point of which baseKey starts in your database. baseKey: string This is the parent key of the keys you are trying to update, see the usage guide for more information. callbacks: {[string]=function(oldData),...} A dictionary of string-keys and function-values, the keys of this table should be the same name as the keys you wish to modify within the 'baseKey' of your database. These functions take a single parameter oldData and should return a table of modified data. This parameter is retrieved internally either from cache [ key ] where key is a key from callbacks , or it will be equal to a : GetAsync ( key ) request if a cache is not provided. cache?: {[string]=table]} Optional parameter used to provide Robase with data that should be newer than what the database has stored. Though it is strongly suggested that you update your database before updating your cache, else you risk losing data if your game crashes before the server can update the database with the cache.","title":"Robase:BatchUpdateAsync"},{"location":"introduction/","text":"Introduction Robase has been in development since June 2020 and has been released since August 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever. Extending the wrapper If you are planning on writing a manager similar to ProfileService using RobaseService, knowledge of Promises will likely be needed. What's the purpose? RobaseService aims to provide a reliable and safe method of saving and loading data, no matter how big or small. But what does it offer that DataStoreService doesn't? But what lets DataStoreService down? Let me explain: You are no longer limited to 4MB of data per key, your database can hold 1GB of storage and you have complete control over how everything is stored. You can access any key within the real-time database, simply use \"/\" to separate the keys. With DataStores you only have access to one point, making querying difficult and ensuring all data exists a slog with sanity checks. Robase is open-sourced, this means that its source code is available to everyone and can be looked at and researched easily - especially with the source documentation ! This will make extending and wrapping RobaseService simpler and creating an extension similar to DataStore2 by Kampfkarren or a manager like ProfileService by loleris. The methods are not guaranteed to be race condition free, Robase uses Promises by evaera to ensure race safety. Every async function will yield until a value is retrieved. In a future release, methods which return the promise may become available Cannot be updated dynamically whenever and however you please. To update a DataStore you have to go into a live game or studio and use the Command Bar to force a key to change, sometimes this just isn't practical. Storage limitations Before using Robase something you may want to ask yourself is: Do I need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Firebase's Spark plan provides you with 1GB storage in total per database/project and 10GB of downloaded data per month. The Blaze plan is priced at how much you use, billed each month; each GB of storage costs $5 per month and each GB downloaded costs $1 per month. With the Blaze plan, a database using 1GB of storage and 100GB downloaded per month will be estimated to pay $105 per month. In addition to this, you get other bonuses. The differences between the Spark and Blaze plan is documented here This example profile shows just how complex and large data can be even when it has been vaguely optimised for storage. This profile will take up 3.6KB of data, that's not so much, right? Now imagine you have 100,000 unique players playing your game, that's now ~352MB, over a third of the capacity for the free plan. That's a lot of data! But this is just player data, what about things that happen in a server? Think about: an experience-wide event, like \"Double XP\" and how you would handle it; or even the optimised metadata for every minigame played; FFlags deployment system. There is a lot of things you can do in the backend of your database and it can be controlled remotely. This example server data gives an example look at how a Firebase structure could be set up as a Lua table. This structure is approximately 2KB in storage. ServerData.PlayedMinigames.Games is approximately 1.5KB in size, each minigame's data equating to 105.5B. What if we asked how much this could grow? Imagine we have a small experience, with about 20,000 visits per day. Now let us say that on average every visit garners 1.8 minigame plays, we can scale this up to how much the database will grow each day. For 20,000 visits we would have 36,000 minigames played - that's roughly 3.62MB! Just how scalable and manageable is this? Well first we have to allow some assumptions: We reserve 500MB in data for player data, the server can use the rest of it. Growth is static and the number of visits/plays per day remains the same (20,000). Minigames Played to Experience Visits ratio is 1.8. local MaxServerData = 1 * 1024 * 1024 * 1024 -- 1GB in Bytes local VisitsPerDay = 20 * 1000 -- 20,000 Visits per day local MinigamesVisitsRatio = 1.8 -- Every visit receives on average 1.8 minigame plays local MinigamesPerDay = VisitsPerDay * MinigamesVisitsRatio -- do mult local MinigamesStorageCostPerDay = 105.5 * MinigamesPerDay -- in Bytes/day local MaxUsage = MaxServerData / 2 local DaysUntilMaxUsage = MaxUsage / MinigamesStorageCostPerDay print ( DaysUntilMaxUsage ) -->> 141.35... Info This is just one example of what one can do with large data. The possibilities are down to your imagination. Accessing deeply-nested keys Being able to access a deeply-nested key can be helpful for a few reasons: It can save on the HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Gruesome sanity checks are a thing of the past! Making a request to a key using ::GetAsync() will always return profound information: (success: boolean, value: any) Success is either true or an error is thrown. Value will be the response body with a successful request or the whole response dictionary if it fails. Extending Robase and managing your data Writing a custom manager similar to DataStore2 or ProfileService may seem daunting at first, but as long as you are safe and secure when handling your data, it does not need to be as developed and can simply be a primitive version of them, but take note: Key Information Cache is a necessity; Session-Locking is recommended; You should write parsers to form keys to access data when needed; Downloading the whole database for each server is cumbersome and can lead to eating through your data usage, only access data that's needed, de-serialise your data appropriately; Check out the source code for insight into how the code works! Why Promises? Quote The way Roblox models asynchronous operations by default is by yielding (stopping) the thread and then resuming it when the future value is available. This model is not ideal because: Functions you call can yield without warning, or only yield sometimes, leading to unpredictable and surprising results. Accidentally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into. It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery. When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful. Yielding lacks easy access to introspection and the ability to cancel an operation if the value is no longer needed. Source: why you should use promises Dynamic Updates Every key in your Firebase Realtime Database can be modified from the Firebase Console. This allows for some unique behaviour that you couldn't otherwise do without loading up the client and entering the game yourself to modify DataStores through the command bar - which is slow and can be complicated. With a Realtime Database, you can have functions that check keys periodically or do something at specific times, or enable/disable beta features/content for your players depending on the value received. As noted in our example, Double XP is a perfect example of a timed event that can run via your database. You can set a key, say \"Activate\" to true, and then watch as your game-code updates and displays that the event is in progress and updates accordingly. You can create a Fast-Flag deployment system for your game. This is the deployment system Roblox uses to enable and disable features. This is possible with DataStoreService but it isn't as easy or convenient.","title":"Introduction"},{"location":"introduction/#introduction","text":"Robase has been in development since June 2020 and has been released since August 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever. Extending the wrapper If you are planning on writing a manager similar to ProfileService using RobaseService, knowledge of Promises will likely be needed.","title":"Introduction"},{"location":"introduction/#whats-the-purpose","text":"RobaseService aims to provide a reliable and safe method of saving and loading data, no matter how big or small. But what does it offer that DataStoreService doesn't? But what lets DataStoreService down? Let me explain: You are no longer limited to 4MB of data per key, your database can hold 1GB of storage and you have complete control over how everything is stored. You can access any key within the real-time database, simply use \"/\" to separate the keys. With DataStores you only have access to one point, making querying difficult and ensuring all data exists a slog with sanity checks. Robase is open-sourced, this means that its source code is available to everyone and can be looked at and researched easily - especially with the source documentation ! This will make extending and wrapping RobaseService simpler and creating an extension similar to DataStore2 by Kampfkarren or a manager like ProfileService by loleris. The methods are not guaranteed to be race condition free, Robase uses Promises by evaera to ensure race safety. Every async function will yield until a value is retrieved. In a future release, methods which return the promise may become available Cannot be updated dynamically whenever and however you please. To update a DataStore you have to go into a live game or studio and use the Command Bar to force a key to change, sometimes this just isn't practical.","title":"What's the purpose?"},{"location":"introduction/#storage-limitations","text":"Before using Robase something you may want to ask yourself is: Do I need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Firebase's Spark plan provides you with 1GB storage in total per database/project and 10GB of downloaded data per month. The Blaze plan is priced at how much you use, billed each month; each GB of storage costs $5 per month and each GB downloaded costs $1 per month. With the Blaze plan, a database using 1GB of storage and 100GB downloaded per month will be estimated to pay $105 per month. In addition to this, you get other bonuses. The differences between the Spark and Blaze plan is documented here This example profile shows just how complex and large data can be even when it has been vaguely optimised for storage. This profile will take up 3.6KB of data, that's not so much, right? Now imagine you have 100,000 unique players playing your game, that's now ~352MB, over a third of the capacity for the free plan. That's a lot of data! But this is just player data, what about things that happen in a server? Think about: an experience-wide event, like \"Double XP\" and how you would handle it; or even the optimised metadata for every minigame played; FFlags deployment system. There is a lot of things you can do in the backend of your database and it can be controlled remotely. This example server data gives an example look at how a Firebase structure could be set up as a Lua table. This structure is approximately 2KB in storage. ServerData.PlayedMinigames.Games is approximately 1.5KB in size, each minigame's data equating to 105.5B. What if we asked how much this could grow? Imagine we have a small experience, with about 20,000 visits per day. Now let us say that on average every visit garners 1.8 minigame plays, we can scale this up to how much the database will grow each day. For 20,000 visits we would have 36,000 minigames played - that's roughly 3.62MB! Just how scalable and manageable is this? Well first we have to allow some assumptions: We reserve 500MB in data for player data, the server can use the rest of it. Growth is static and the number of visits/plays per day remains the same (20,000). Minigames Played to Experience Visits ratio is 1.8. local MaxServerData = 1 * 1024 * 1024 * 1024 -- 1GB in Bytes local VisitsPerDay = 20 * 1000 -- 20,000 Visits per day local MinigamesVisitsRatio = 1.8 -- Every visit receives on average 1.8 minigame plays local MinigamesPerDay = VisitsPerDay * MinigamesVisitsRatio -- do mult local MinigamesStorageCostPerDay = 105.5 * MinigamesPerDay -- in Bytes/day local MaxUsage = MaxServerData / 2 local DaysUntilMaxUsage = MaxUsage / MinigamesStorageCostPerDay print ( DaysUntilMaxUsage ) -->> 141.35... Info This is just one example of what one can do with large data. The possibilities are down to your imagination.","title":"Storage limitations"},{"location":"introduction/#accessing-deeply-nested-keys","text":"Being able to access a deeply-nested key can be helpful for a few reasons: It can save on the HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Gruesome sanity checks are a thing of the past! Making a request to a key using ::GetAsync() will always return profound information: (success: boolean, value: any) Success is either true or an error is thrown. Value will be the response body with a successful request or the whole response dictionary if it fails.","title":"Accessing deeply-nested keys"},{"location":"introduction/#extending-robase-and-managing-your-data","text":"Writing a custom manager similar to DataStore2 or ProfileService may seem daunting at first, but as long as you are safe and secure when handling your data, it does not need to be as developed and can simply be a primitive version of them, but take note: Key Information Cache is a necessity; Session-Locking is recommended; You should write parsers to form keys to access data when needed; Downloading the whole database for each server is cumbersome and can lead to eating through your data usage, only access data that's needed, de-serialise your data appropriately; Check out the source code for insight into how the code works!","title":"Extending Robase and managing your data"},{"location":"introduction/#why-promises","text":"Quote The way Roblox models asynchronous operations by default is by yielding (stopping) the thread and then resuming it when the future value is available. This model is not ideal because: Functions you call can yield without warning, or only yield sometimes, leading to unpredictable and surprising results. Accidentally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into. It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery. When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful. Yielding lacks easy access to introspection and the ability to cancel an operation if the value is no longer needed. Source: why you should use promises","title":"Why Promises?"},{"location":"introduction/#dynamic-updates","text":"Every key in your Firebase Realtime Database can be modified from the Firebase Console. This allows for some unique behaviour that you couldn't otherwise do without loading up the client and entering the game yourself to modify DataStores through the command bar - which is slow and can be complicated. With a Realtime Database, you can have functions that check keys periodically or do something at specific times, or enable/disable beta features/content for your players depending on the value received. As noted in our example, Double XP is a perfect example of a timed event that can run via your database. You can set a key, say \"Activate\" to true, and then watch as your game-code updates and displays that the event is in progress and updates accordingly. You can create a Fast-Flag deployment system for your game. This is the deployment system Roblox uses to enable and disable features. This is possible with DataStoreService but it isn't as easy or convenient.","title":"Dynamic Updates"},{"location":"Guide/installation/","text":"Installation There are two methods to get up and running with Robase. For our examples, we will install RobaseService into ReplicatedStorage . Note, it's okay to install RobaseService wherever you want. Method A: Roblox Model (via Roblox Studio) Caution Roblox Models can be outdated, the suggested installation method is Method B. Todo Write documentation for Roblox Model. Method B: Filesystem (via Rojo) Go to the Github Releases and download the latest stable release of RobaseService. Save it somewhere meaningful so you only need to download it once. Open your working directory in your preferred IDE and sync your files with an empty studio using Rojo ! Copy the source wherever you wish, ReplicatedStorage is recommended. Continue developing!","title":"Installation"},{"location":"Guide/installation/#installation","text":"There are two methods to get up and running with Robase. For our examples, we will install RobaseService into ReplicatedStorage . Note, it's okay to install RobaseService wherever you want.","title":"Installation"},{"location":"Guide/installation/#method-a-roblox-model-via-roblox-studio","text":"Caution Roblox Models can be outdated, the suggested installation method is Method B. Todo Write documentation for Roblox Model.","title":"Method A: Roblox Model (via Roblox Studio)"},{"location":"Guide/installation/#method-b-filesystem-via-rojo","text":"Go to the Github Releases and download the latest stable release of RobaseService. Save it somewhere meaningful so you only need to download it once. Open your working directory in your preferred IDE and sync your files with an empty studio using Rojo ! Copy the source wherever you wish, ReplicatedStorage is recommended. Continue developing!","title":"Method B: Filesystem (via Rojo)"},{"location":"Guide/setup/","text":"Setting up Robase Warning This page is still in the process of being documented. RobaseService is made to be a replication of DataStoreService so that setup and transferring data is simple to do. Setup Example Code that once looked like this: local DataStoreService = game : GetService ( \"DataStoreService\" ) local ExampleDataStore = DataStoreService : GetDataStore ( \"Example\" ) local ExampleData = ExampleDataStore : GetAsync ( \"123456789\" ) Will now look like this: local RobaseServiceModule = require ( path . to . robase ) local RobaseService = RobaseServiceModule . new ( \"URL\" , \"AUTH\" ) local ExampleRobase = RobaseService : GetRobase ( \"NAME\" ) local Success , Result = ExampleRobase : GetAsync ( \"KEY\" ) Every method call to a Robase will return a Success and a Result , check the API Reference for more detailed information. Transferring from DataStoreService The following is relevant code to transfer player data from DataStoreService to RobaseService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local DataStoreName = \"Enter DataStore Name\" local FirebaseAuthKey = \"Enter Firebase Auth Key\" local FirebaseDBUrl = \"Enter Firebase DB Url\" local RobaseName = \"Enter Robase Name\" local DataStoreService = game : GetService ( \"DataStoreService\" ) local RobaseServiceModule = require ( \"path.to.robase\" ) local RobaseService = RobaseServiceModule . new ( FirebaseDBUrl , FirebaseAuthKey ) local GlobalDataStore = game : GetDataStore ( DataStoreName ) local GlobalRobase = RobaseService : GetRobase ( RobaseName ) game : GetService ( \"Players\" ). PlayerAdded : Connect ( function ( player ) local DS_Key = string.format ( \"%d\" , player . UserId ) -- replace with DataStore key format, for example: string.format(\"Players/%d\", player.UserId) local RobaseKey = string.format ( \"%d\" , player . UserId ) -- replace with Robase key format for example: string.format(\"Players/%d\", player.UserId) local ExistsInRobase , Result = GlobalRobase : GetAsync ( RobaseKey ) local SavedData = GlobalDataStore : GetAsync ( DS_Key ) or nil if not ExistsInRobase and SavedData then -- Key does not exist in the Firebase and data was found in the DataStore -- so we save it ExistsInRobase , Result = GlobalRobase : SetAsync ( RobaseKey , SavedData , \"POST\" ) --[[if ExistsInRobase then -- perform sanity checks however you wish end]] end end )","title":"Setup"},{"location":"Guide/setup/#setting-up-robase","text":"Warning This page is still in the process of being documented. RobaseService is made to be a replication of DataStoreService so that setup and transferring data is simple to do.","title":"Setting up Robase"},{"location":"Guide/setup/#setup-example","text":"Code that once looked like this: local DataStoreService = game : GetService ( \"DataStoreService\" ) local ExampleDataStore = DataStoreService : GetDataStore ( \"Example\" ) local ExampleData = ExampleDataStore : GetAsync ( \"123456789\" ) Will now look like this: local RobaseServiceModule = require ( path . to . robase ) local RobaseService = RobaseServiceModule . new ( \"URL\" , \"AUTH\" ) local ExampleRobase = RobaseService : GetRobase ( \"NAME\" ) local Success , Result = ExampleRobase : GetAsync ( \"KEY\" ) Every method call to a Robase will return a Success and a Result , check the API Reference for more detailed information.","title":"Setup Example"},{"location":"Guide/setup/#transferring-from-datastoreservice","text":"The following is relevant code to transfer player data from DataStoreService to RobaseService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local DataStoreName = \"Enter DataStore Name\" local FirebaseAuthKey = \"Enter Firebase Auth Key\" local FirebaseDBUrl = \"Enter Firebase DB Url\" local RobaseName = \"Enter Robase Name\" local DataStoreService = game : GetService ( \"DataStoreService\" ) local RobaseServiceModule = require ( \"path.to.robase\" ) local RobaseService = RobaseServiceModule . new ( FirebaseDBUrl , FirebaseAuthKey ) local GlobalDataStore = game : GetDataStore ( DataStoreName ) local GlobalRobase = RobaseService : GetRobase ( RobaseName ) game : GetService ( \"Players\" ). PlayerAdded : Connect ( function ( player ) local DS_Key = string.format ( \"%d\" , player . UserId ) -- replace with DataStore key format, for example: string.format(\"Players/%d\", player.UserId) local RobaseKey = string.format ( \"%d\" , player . UserId ) -- replace with Robase key format for example: string.format(\"Players/%d\", player.UserId) local ExistsInRobase , Result = GlobalRobase : GetAsync ( RobaseKey ) local SavedData = GlobalDataStore : GetAsync ( DS_Key ) or nil if not ExistsInRobase and SavedData then -- Key does not exist in the Firebase and data was found in the DataStore -- so we save it ExistsInRobase , Result = GlobalRobase : SetAsync ( RobaseKey , SavedData , \"POST\" ) --[[if ExistsInRobase then -- perform sanity checks however you wish end]] end end )","title":"Transferring from DataStoreService"},{"location":"Guide/usage/","text":"Usage Guide Warning This page is still in the process of being documented. In the following examples, we will go over and take a look into the Robase Test Database. The structure of which can be seen below. Although it is not an ideal structure, it is just an example of what one could potentially look like. It is solely used to test Robase functionality and nothing more, you should not read into the naming of these keys as they are display only and provide no functional or tangible purpose outside of testing. Important These examples assume you have installed Robase already and have required it with a valid path. Initialising RobaseService To begin using Robase you must first initialise it. This requires two parameters: baseUrl and token . You can go here to learn more about acquiring these and how to safely store them. Danger For security purposes it is highly recommended that you do not store your Database Url and Database Secrets in plain text in your code. Consider using DataStoreService to handle this securely. local ExampleRobaseService = RobaseService . new ( \"https://your-firebase-realtime-database-url\" , --> baseUrl \"YourFirebaseAuthTokenSecret\" --> token ) Getting a Robase You can retrieve a Robase object several ways at any level in your database. You can do this using the : GetRobase () method of RobaseService. This method has no required parameters - so you can access top-level elements in your database without creating new Robase objects for them - though, it is recommended to provide a name and create individual Robase objects for each top-level element you wish to work on, purely for readability-sake. name The name of the element in your database that you wish to point the Robase to. scope The depth of the database, it is put before the name in the Url We will cover using both of these and neither of these in the following sections. Warning Do not prefix or suffix your name, keys, or scopes with \"/\", RobaseService will do this for you. Providing a name without scope This is simply put going to search the top-level of your database for the provided name, in our example, we have \"PlayerData\", so let's set up our Robase there. local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" ) Providing a name and a scope But, what if we want to access a deeper element in our database, and set up a Robase at that point? Well, we can, and it's very simple! Just provide a scope with the name! So for this example, we will access the \"Players\" array within \"BatchUpdateMe\". local ExampleRobase = RobaseService : GetRobase ( \"Players\" , --> \"Name\" of the key to search for \"PlayerData/GetDataHere/BatchUpdateMe\" --> \"Scope\" of where to search for \"Name\" ) Providing no information This method is used solely to grab the entire database, top-level keys and all! This allows us to perform :GetAsync() requests into any top-level key and get the table or data located at that point, like so: local ExampleRobase = RobaseService : GetRobase () It's that simple. So now you have your Robase, what next? Getting Data One of the fundamental parts of your game will be saving and loading player data. To start, we will be acquiring some data from the database, for this case, we will create a Robase at \"PlayerData\" and acquire the data located at \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" ) local Success , ExampleData = ExampleRobase : GetAsync ( \"GetDataHere\" ) print ( ExampleData ) The above code will print out the table located at \"GetDataHere\". Saving data There are a few saving options in Robase, these are quite similar to DataStoreService: SetAsync will create new data or replace old data at the given key using a PUT request if no method is provided. UpdateAsync will modify the data at the given key using a PATCH request. BatchUpdateAsync will modify a set of keys using a PATCH request. The decision to use PUT over POST requests by default was an easy one to make - it's idempotent, meaning successive calls will always provide the same response and will have zero side effects. Using SetAsync First, we will cover the basic SetAsync method. This time around, we will create a Robase at \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local NewData = { Admin = false } ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData ) -- The above is equivalent to the following: local Success , Result = ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData ) local Success , Result = ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData , \"PUT\" ) ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData , \"PUT\" ) Updating your data In most cases though, you will want to opt for updating your data instead, in this case, we UpdateAsync . This method has one key difference from DataStoreService: the cache parameter. Robase was made with caches in mind such that you will use fewer requests and can take advantage of the powerful BatchUpdateAsync method. You can extend upon this feature nicely by writing a custom data handler module and having your saving/updating use Write-through - change the database first, and then the cache. Though, we will not be showcasing this functionality here. Currently, neither of these methods support retries and this functionality will have to be written at the call site of these methods. Using UpdateAsync For this example, we will create a Robase at \"PlayerData\" and we will be updating the \"GetDataHere\" key. local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" ) local NewData = { [ \"UpdateWhatever\" ] = \"How are?!\" } ExampleRobase : UpdateAsync ( \"GetDataHere\" , function ( oldData ) return NewData end ) -- Again, the above is also equivalent to: local Success , Result = ExampleRobase : UpdateAsync ( \"GetDataHere\" , function ( oldData ) return NewData end ) Warning You can only update or modify keys that are a table, you cannot send a request directly to \"UpdateWhatever\", this will fail. Using BatchUpdateAsync This is where things get a teeny bit more complicated, for this method you must define your callback methods and populate a table with them. This time, we will modify the data located at \"BatchUpdateMe\" within \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local NewData = { Players = { [ \"789\" ] = { Coins = 123456789 , Level = 99 } }, Server = { LastUpdated = os.date () } } local Updaters = { Players = function ( oldData ) return NewData . Players end , Server = function ( oldData ) return NewData . Server end } ExampleRobase : BatchUpdateAsync ( \"BatchUpdateMe\" , Updaters ) -- Equivalent to: local Success , Result = ExampleRobase : BatchUpdateAsync ( \"BatchUpdateMe\" , Updaters ) Incrementing Data Just like DataStoreService, RobaseService offers an IncrementAsync function which works similarly to the aforementioned DataStoreService method. Warning Attempting to increment data that is not an integer will throw an error. Numbers and any other data type are not acceptable types to increment. Again, we will be creating our Robase at \"GetDataHere\", but this time we will perform two basic operations on the \"IncrementThat\" key. local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local Success , Result = ExampleRobase : IncrementAsync ( \"IncrementThat\" ) print ( Result ) -->> 51 Success , Result = Example : Robase : IncrementAsync ( \"IncrementThat\" , 24 ) print ( Result ) -->> 75 Deleting Data For whatever reason, you have decided to completely wipe some data from your database, why you would want to do this is your own reason, but this method exists, so let's demonstrate it: local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local Success , Result = ExampleRobase : DeleteAsync ( \"IPutThisHereRemotely\" ) print ( Result ) -->> true The result returned from DeleteAsync will give you the previously stored data, this is useful for if you've made an oopsie and want to fix it. I'd rather not keep this data deleted, so I'm going to put it back: Success , Result = ExampleRobase : SetAsync ( \"IPutThisHereRemotely\" , Result ) print ( Result ) -->> true The main use-case that I can think of for wanting to properly use this, ever, is if you provide clients with the option to delete their data from the database.","title":"Usage Guide"},{"location":"Guide/usage/#usage-guide","text":"Warning This page is still in the process of being documented. In the following examples, we will go over and take a look into the Robase Test Database. The structure of which can be seen below. Although it is not an ideal structure, it is just an example of what one could potentially look like. It is solely used to test Robase functionality and nothing more, you should not read into the naming of these keys as they are display only and provide no functional or tangible purpose outside of testing. Important These examples assume you have installed Robase already and have required it with a valid path.","title":"Usage Guide"},{"location":"Guide/usage/#initialising-robaseservice","text":"To begin using Robase you must first initialise it. This requires two parameters: baseUrl and token . You can go here to learn more about acquiring these and how to safely store them. Danger For security purposes it is highly recommended that you do not store your Database Url and Database Secrets in plain text in your code. Consider using DataStoreService to handle this securely. local ExampleRobaseService = RobaseService . new ( \"https://your-firebase-realtime-database-url\" , --> baseUrl \"YourFirebaseAuthTokenSecret\" --> token )","title":"Initialising RobaseService"},{"location":"Guide/usage/#getting-a-robase","text":"You can retrieve a Robase object several ways at any level in your database. You can do this using the : GetRobase () method of RobaseService. This method has no required parameters - so you can access top-level elements in your database without creating new Robase objects for them - though, it is recommended to provide a name and create individual Robase objects for each top-level element you wish to work on, purely for readability-sake. name The name of the element in your database that you wish to point the Robase to. scope The depth of the database, it is put before the name in the Url We will cover using both of these and neither of these in the following sections. Warning Do not prefix or suffix your name, keys, or scopes with \"/\", RobaseService will do this for you.","title":"Getting a Robase"},{"location":"Guide/usage/#providing-a-name-without-scope","text":"This is simply put going to search the top-level of your database for the provided name, in our example, we have \"PlayerData\", so let's set up our Robase there. local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" )","title":"Providing a name without scope"},{"location":"Guide/usage/#providing-a-name-and-a-scope","text":"But, what if we want to access a deeper element in our database, and set up a Robase at that point? Well, we can, and it's very simple! Just provide a scope with the name! So for this example, we will access the \"Players\" array within \"BatchUpdateMe\". local ExampleRobase = RobaseService : GetRobase ( \"Players\" , --> \"Name\" of the key to search for \"PlayerData/GetDataHere/BatchUpdateMe\" --> \"Scope\" of where to search for \"Name\" )","title":"Providing a name and a scope"},{"location":"Guide/usage/#providing-no-information","text":"This method is used solely to grab the entire database, top-level keys and all! This allows us to perform :GetAsync() requests into any top-level key and get the table or data located at that point, like so: local ExampleRobase = RobaseService : GetRobase () It's that simple. So now you have your Robase, what next?","title":"Providing no information"},{"location":"Guide/usage/#getting-data","text":"One of the fundamental parts of your game will be saving and loading player data. To start, we will be acquiring some data from the database, for this case, we will create a Robase at \"PlayerData\" and acquire the data located at \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" ) local Success , ExampleData = ExampleRobase : GetAsync ( \"GetDataHere\" ) print ( ExampleData ) The above code will print out the table located at \"GetDataHere\".","title":"Getting Data"},{"location":"Guide/usage/#saving-data","text":"There are a few saving options in Robase, these are quite similar to DataStoreService: SetAsync will create new data or replace old data at the given key using a PUT request if no method is provided. UpdateAsync will modify the data at the given key using a PATCH request. BatchUpdateAsync will modify a set of keys using a PATCH request. The decision to use PUT over POST requests by default was an easy one to make - it's idempotent, meaning successive calls will always provide the same response and will have zero side effects.","title":"Saving data"},{"location":"Guide/usage/#using-setasync","text":"First, we will cover the basic SetAsync method. This time around, we will create a Robase at \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local NewData = { Admin = false } ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData ) -- The above is equivalent to the following: local Success , Result = ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData ) local Success , Result = ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData , \"PUT\" ) ExampleRobase : SetAsync ( \"ExtraConfig\" , NewData , \"PUT\" )","title":"Using SetAsync"},{"location":"Guide/usage/#updating-your-data","text":"In most cases though, you will want to opt for updating your data instead, in this case, we UpdateAsync . This method has one key difference from DataStoreService: the cache parameter. Robase was made with caches in mind such that you will use fewer requests and can take advantage of the powerful BatchUpdateAsync method. You can extend upon this feature nicely by writing a custom data handler module and having your saving/updating use Write-through - change the database first, and then the cache. Though, we will not be showcasing this functionality here. Currently, neither of these methods support retries and this functionality will have to be written at the call site of these methods.","title":"Updating your data"},{"location":"Guide/usage/#using-updateasync","text":"For this example, we will create a Robase at \"PlayerData\" and we will be updating the \"GetDataHere\" key. local ExampleRobase = RobaseService : GetRobase ( \"PlayerData\" ) local NewData = { [ \"UpdateWhatever\" ] = \"How are?!\" } ExampleRobase : UpdateAsync ( \"GetDataHere\" , function ( oldData ) return NewData end ) -- Again, the above is also equivalent to: local Success , Result = ExampleRobase : UpdateAsync ( \"GetDataHere\" , function ( oldData ) return NewData end ) Warning You can only update or modify keys that are a table, you cannot send a request directly to \"UpdateWhatever\", this will fail.","title":"Using UpdateAsync"},{"location":"Guide/usage/#using-batchupdateasync","text":"This is where things get a teeny bit more complicated, for this method you must define your callback methods and populate a table with them. This time, we will modify the data located at \"BatchUpdateMe\" within \"GetDataHere\". local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local NewData = { Players = { [ \"789\" ] = { Coins = 123456789 , Level = 99 } }, Server = { LastUpdated = os.date () } } local Updaters = { Players = function ( oldData ) return NewData . Players end , Server = function ( oldData ) return NewData . Server end } ExampleRobase : BatchUpdateAsync ( \"BatchUpdateMe\" , Updaters ) -- Equivalent to: local Success , Result = ExampleRobase : BatchUpdateAsync ( \"BatchUpdateMe\" , Updaters )","title":"Using BatchUpdateAsync"},{"location":"Guide/usage/#incrementing-data","text":"Just like DataStoreService, RobaseService offers an IncrementAsync function which works similarly to the aforementioned DataStoreService method. Warning Attempting to increment data that is not an integer will throw an error. Numbers and any other data type are not acceptable types to increment. Again, we will be creating our Robase at \"GetDataHere\", but this time we will perform two basic operations on the \"IncrementThat\" key. local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local Success , Result = ExampleRobase : IncrementAsync ( \"IncrementThat\" ) print ( Result ) -->> 51 Success , Result = Example : Robase : IncrementAsync ( \"IncrementThat\" , 24 ) print ( Result ) -->> 75","title":"Incrementing Data"},{"location":"Guide/usage/#deleting-data","text":"For whatever reason, you have decided to completely wipe some data from your database, why you would want to do this is your own reason, but this method exists, so let's demonstrate it: local ExampleRobase = RobaseService : GetRobase ( \"GetDataHere\" , \"PlayerData\" ) local Success , Result = ExampleRobase : DeleteAsync ( \"IPutThisHereRemotely\" ) print ( Result ) -->> true The result returned from DeleteAsync will give you the previously stored data, this is useful for if you've made an oopsie and want to fix it. I'd rather not keep this data deleted, so I'm going to put it back: Success , Result = ExampleRobase : SetAsync ( \"IPutThisHereRemotely\" , Result ) print ( Result ) -->> true The main use-case that I can think of for wanting to properly use this, ever, is if you provide clients with the option to delete their data from the database.","title":"Deleting Data"}]}