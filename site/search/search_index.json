{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robase Site in progress This website is still a work in progress and changes are being made daily. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here .","title":"Home"},{"location":"#robase","text":"Site in progress This website is still a work in progress and changes are being made daily. Robase is a RESTful API wrapper for Firebase Realtime Database - written in untyped Luau - for Roblox Developers seeking an external database service with a simple to use wrapper. As mentioned, Robase seeks to be simple to use, but this is one of two core aims of this project. The second aim is to be an easy replacement to DataStoreService . You can find useful code to help with replacing old DataStore code and transferring data here .","title":"Robase"},{"location":"api/","text":"API Reference Warning This page is still in the process of being documented. RobaseService Caution RobaseService cannot be used without first instantiating it with .new and providing a Firebase Database Url and a Secrets Authentication Token. RobaseService.new RobaseService . new ( baseUrl : string , token : string ) --> RobaseService Used to instantiate a new RobaseService with the provided Url and Auth Token. RobaseService:GetRobase RobaseService : GetRobase ( name : string , [ scope : string ]) --> Robase Used to retrieve a Robase object with a path supplied from scope and name. Robase Caution Robase will handle failed requests automatically by throwing an error. They will never return (false, any) but they can return (true, nil) Robase:GetAsync Robase : GetAsync ( key : string ) --> Success: Boolean, Result: any Retrieves the data stored at the given key within the Robase. Robase:SetAsync Robase : SetAsync ( key : string , data : any , [ method : string ]) --> Success: Boolean, Result: any Adds data into the Robase at the key specified using the given method. The method parameter is optional and is mainly used internally to differentiate requests. PUT / PATCH / DELETE / POST are all valid method types. Defaults to PUT requests. Robase:IncrementAsync Robase : IncrementAsync ( key : string , [ delta : integer ]) --> Success: Boolean, Result: any Usage restrictions You can only use ::IncrementAsync on keys with integer values! Delta must be an integer or nil! Increments the data stored at the given key by the supplied delta. This only works on key's which have an integer value and with an integer-only delta (ex. 1.5 will not work) Delta is an optional parameter and will default to 1 if not supplied. Robase:DeleteAsync Robase : DeleteAsync ( key : string ) --> Success: Boolean, Result: any Dangerous This method is incredible dangerous. It can delete entire trees of data and cannot be rolled back. It will return the data previously stored at the key given. Robase:UpdateAsync Robase : UpdateAsync ( key : string , callback : Function , [ cache : table ]) --> Success: Boolean, Result: any Retrieves data from the Robase at the key given, or from the cache if provided and transforms it using the callback function and updates the key with a new value. Robase:BatchUpdateAsync Robase : BatchUpdateAsync ( baseKey : string , callbacks : table , [ cache : table ]) --> Success: Boolean, Result: any Similar in functionality to :UpdateAsync except will take a baseKey and then use the keys from the callbacks array to form a key to update using the provided callback function to update the value.","title":"API Reference"},{"location":"api/#api-reference","text":"Warning This page is still in the process of being documented.","title":"API Reference"},{"location":"api/#robaseservice","text":"Caution RobaseService cannot be used without first instantiating it with .new and providing a Firebase Database Url and a Secrets Authentication Token.","title":"RobaseService"},{"location":"api/#robaseservicenew","text":"RobaseService . new ( baseUrl : string , token : string ) --> RobaseService Used to instantiate a new RobaseService with the provided Url and Auth Token.","title":"RobaseService.new"},{"location":"api/#robaseservicegetrobase","text":"RobaseService : GetRobase ( name : string , [ scope : string ]) --> Robase Used to retrieve a Robase object with a path supplied from scope and name.","title":"RobaseService:GetRobase"},{"location":"api/#robase","text":"Caution Robase will handle failed requests automatically by throwing an error. They will never return (false, any) but they can return (true, nil)","title":"Robase"},{"location":"api/#robasegetasync","text":"Robase : GetAsync ( key : string ) --> Success: Boolean, Result: any Retrieves the data stored at the given key within the Robase.","title":"Robase:GetAsync"},{"location":"api/#robasesetasync","text":"Robase : SetAsync ( key : string , data : any , [ method : string ]) --> Success: Boolean, Result: any Adds data into the Robase at the key specified using the given method. The method parameter is optional and is mainly used internally to differentiate requests. PUT / PATCH / DELETE / POST are all valid method types. Defaults to PUT requests.","title":"Robase:SetAsync"},{"location":"api/#robaseincrementasync","text":"Robase : IncrementAsync ( key : string , [ delta : integer ]) --> Success: Boolean, Result: any Usage restrictions You can only use ::IncrementAsync on keys with integer values! Delta must be an integer or nil! Increments the data stored at the given key by the supplied delta. This only works on key's which have an integer value and with an integer-only delta (ex. 1.5 will not work) Delta is an optional parameter and will default to 1 if not supplied.","title":"Robase:IncrementAsync"},{"location":"api/#robasedeleteasync","text":"Robase : DeleteAsync ( key : string ) --> Success: Boolean, Result: any Dangerous This method is incredible dangerous. It can delete entire trees of data and cannot be rolled back. It will return the data previously stored at the key given.","title":"Robase:DeleteAsync"},{"location":"api/#robaseupdateasync","text":"Robase : UpdateAsync ( key : string , callback : Function , [ cache : table ]) --> Success: Boolean, Result: any Retrieves data from the Robase at the key given, or from the cache if provided and transforms it using the callback function and updates the key with a new value.","title":"Robase:UpdateAsync"},{"location":"api/#robasebatchupdateasync","text":"Robase : BatchUpdateAsync ( baseKey : string , callbacks : table , [ cache : table ]) --> Success: Boolean, Result: any Similar in functionality to :UpdateAsync except will take a baseKey and then use the keys from the callbacks array to form a key to update using the provided callback function to update the value.","title":"Robase:BatchUpdateAsync"},{"location":"introduction/","text":"Introduction Robase has been in development since June 2020 and has been released since August 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever. Extending the wrapper If you are planning on writing a manager similar to ProfileService using RobaseService, knowledge of Promises will likely be needed. What's the purpose? RobaseService aims to provide a reliable and safe method of saving and loading data, no matter how big or small. But what lets DataStoreService down? Let me explain: You are limited to 4MB of data per key, with keys having a smaller max length than Firebase. You can only access top-level keys (generally, this is Player.UserId ) and must define a path to a given point with table notation. ( table.this.that ). DataStoreService's internals are not exposed, meaning it is a strenuous task to figure out how exactly every method works as well as some involved research. Robase is open-sourced, this means that it's source code is available to everyone and can be looked at and researched easily - especially with the source documentation! This will make extending and wrapping RobaseService simpler and creating a manager similar to DataStore2 by Kampfkarren or ProfileService by loleris. The methods are not guranteed to be race condition free, Robase uses Promises by evaera to ensure race safety. Every async function will yield until a value is retrieved. In a future release, synchronous operations which return the promise may become available Cannot be updated dynamically, from anywhere, at anytime. This makes systems such as FFlags not possible, A/B Testing extraneous, and timed-events that can turn on at a moment's notice in a live game - impossible. With Robase however, this is very simple. Storage limitations Before using Robase something you may want to ask yourself is: Do I really need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Firebase's Spark plan provides you with 1GB storage in total per database/project and 10GB data downloaded per month. The Blaze plan is priced at how much you are using each, billed each month; each GB of storage costs $5 per month and each GB downloaded costs $1 per month. With the Blaze plan, a database using 1GB of storage and 100GB downloaded per month will be estimated to pay $105 per month. In addition to this you get other bonuses. The differences between the Spark and Blaze plan is documented here This example profile shows just how complex and large data can be even when it has been optimised for storage. This profile will take up 3.6KB of data, that's not so much, right? Now imagine you have 100,000 unique players playing your game, that's now ~352MB, over a third of the capacity for the free plan. That's a lot of data! But this is just player data, what about things that happen in a server? Think about: an experience-wide event, like \"Double XP\" and how would you handle it; or even the optimised metadata for every minigame played; FFlags deployment system. There is a lot of things you can do in the backend of your database and it can be controlled remotely. This example server data gives an example look at how a Firebase structure could be setup as a Lua table. This structure is approximately 2KB in storage. ServerData.PlayedMinigames.Games is approximately 1.5KB in size, each minigame's data equating to 105.5B. What if we asked how much this could grow? Imagine we have a small experience, with about 20,000 visits per day. Now lets say that on average every visit garners 1.8 minigame plays, we can scale this up to how much the database will grow each day. For 20,000 visits we would have 36,000 minigames played - that's roughly 3.62MB! Just how scalable and manageable is this? Well first we have to allow some assumptions: We reserve 500MB in data for player data, the server can use the rest of it. Growth is static and the number of visists remain the same. Minigames Played to Visits ratio is 1.8. local MaxServerData = 1 * 1024 * 1024 * 1024 -- 1GB in Bytes local VisitsPerDay = 20 * 1000 -- 20,000 Visits per day local MinigamesVisitsRatio = 1.8 -- Every visit receives on average 1.8 minigame plays local MinigamesPerDay = VisitsPerDay * MinigamesVisitsRatio -- do mult local MinigamesStorageCostPerDay = 105.5 * MinigamesPerDay -- in Bytes/day local MaxUsage = MaxServerData / 2 local DaysUntilMaxUsage = MaxUsage / MinigamesStorageCostPerDay print ( DaysUntilMaxUsage ) -->> 141.35... Info This is just one example of what one can do with large data. The possibilities are down to your imagination. Accessing deeply-nested keys Being able to access a deeply-nested key can be helpful for a few reasons: It can save on HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Gruesome sanity checks are a thing of the past! Making a request to a key using ::GetAsync() will always return profound information: (success: boolean, value: string | table) Success is either true or false - if the information was retrieved or sent successfully. Value will be the response body with a successful request or the whole response dictionary if it fails. Extending Robase and managing your data Writing your own manager similar to DataStore2 or ProfileService may seem daunting at first, but as long as you are safe and secure when handling your data, it does not need to be as developed and can simply be a primitive version of them, but take note: Key Information Cache is a necessity; Session-Locking is recommended; You should write parsers to form keys to access data when needed; Downloading the whole database for each server is cumbersome and can lead to eating through your data usage, only access data thats needed, de-serialise your data appropriately; Check out the source code for insight into how the code works! Why Promises? Quote The way Roblox models asynchronous operations by default is by yielding (stopping) the thread and then resuming it when the future value is available. This model is not ideal because: Functions you call can yield without warning, or only yield sometimes, leading to unpredictable and surprising results. Accidentally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into. It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery. When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful. Yielding lacks easy access to introspection and the ability to cancel an operation if the value is no longer needed. Source: why you should use promises Dynamic Updates Every key in your Firebase Realtime Database can be modified from the Firebase Console. This allows for some unique behaviour that you couldn't otherwise do without loading up the client and entering the game yourself to modify DataStores through the command line - which is slow, and can be complicated. With a Realtime Database you can have functions that check keys periodically or do something at specific times, or enable/disable beta features/content for your players depending on the value received. As noted in our example, Double XP is a perfect example of a timed event that can run via your database. You can set a key, say \"Activate\" to true, and then watch as your game-code updates and displays that the event is in progress and updates accordingly. You can have Fast Flags for your game, this is the deployment system Roblox uses to enable and disable content, it's also why bugs can just appear out of nowhere sometime.","title":"Introduction"},{"location":"introduction/#introduction","text":"Robase has been in development since June 2020 and has been released since August 2020. Development first began when the need to store larger and larger data grew and it became apparent that DataStores were not going to be the answer; ever. Extending the wrapper If you are planning on writing a manager similar to ProfileService using RobaseService, knowledge of Promises will likely be needed.","title":"Introduction"},{"location":"introduction/#whats-the-purpose","text":"RobaseService aims to provide a reliable and safe method of saving and loading data, no matter how big or small. But what lets DataStoreService down? Let me explain: You are limited to 4MB of data per key, with keys having a smaller max length than Firebase. You can only access top-level keys (generally, this is Player.UserId ) and must define a path to a given point with table notation. ( table.this.that ). DataStoreService's internals are not exposed, meaning it is a strenuous task to figure out how exactly every method works as well as some involved research. Robase is open-sourced, this means that it's source code is available to everyone and can be looked at and researched easily - especially with the source documentation! This will make extending and wrapping RobaseService simpler and creating a manager similar to DataStore2 by Kampfkarren or ProfileService by loleris. The methods are not guranteed to be race condition free, Robase uses Promises by evaera to ensure race safety. Every async function will yield until a value is retrieved. In a future release, synchronous operations which return the promise may become available Cannot be updated dynamically, from anywhere, at anytime. This makes systems such as FFlags not possible, A/B Testing extraneous, and timed-events that can turn on at a moment's notice in a live game - impossible. With Robase however, this is very simple.","title":"What's the purpose?"},{"location":"introduction/#storage-limitations","text":"Before using Robase something you may want to ask yourself is: Do I really need this? In most cases, DataStore2 or ProfileService will serve you well, though you won't be saving anything big or complex. If you are looking to store large, complex data, then Robase is something you will want in your arsenal. Firebase's Spark plan provides you with 1GB storage in total per database/project and 10GB data downloaded per month. The Blaze plan is priced at how much you are using each, billed each month; each GB of storage costs $5 per month and each GB downloaded costs $1 per month. With the Blaze plan, a database using 1GB of storage and 100GB downloaded per month will be estimated to pay $105 per month. In addition to this you get other bonuses. The differences between the Spark and Blaze plan is documented here This example profile shows just how complex and large data can be even when it has been optimised for storage. This profile will take up 3.6KB of data, that's not so much, right? Now imagine you have 100,000 unique players playing your game, that's now ~352MB, over a third of the capacity for the free plan. That's a lot of data! But this is just player data, what about things that happen in a server? Think about: an experience-wide event, like \"Double XP\" and how would you handle it; or even the optimised metadata for every minigame played; FFlags deployment system. There is a lot of things you can do in the backend of your database and it can be controlled remotely. This example server data gives an example look at how a Firebase structure could be setup as a Lua table. This structure is approximately 2KB in storage. ServerData.PlayedMinigames.Games is approximately 1.5KB in size, each minigame's data equating to 105.5B. What if we asked how much this could grow? Imagine we have a small experience, with about 20,000 visits per day. Now lets say that on average every visit garners 1.8 minigame plays, we can scale this up to how much the database will grow each day. For 20,000 visits we would have 36,000 minigames played - that's roughly 3.62MB! Just how scalable and manageable is this? Well first we have to allow some assumptions: We reserve 500MB in data for player data, the server can use the rest of it. Growth is static and the number of visists remain the same. Minigames Played to Visits ratio is 1.8. local MaxServerData = 1 * 1024 * 1024 * 1024 -- 1GB in Bytes local VisitsPerDay = 20 * 1000 -- 20,000 Visits per day local MinigamesVisitsRatio = 1.8 -- Every visit receives on average 1.8 minigame plays local MinigamesPerDay = VisitsPerDay * MinigamesVisitsRatio -- do mult local MinigamesStorageCostPerDay = 105.5 * MinigamesPerDay -- in Bytes/day local MaxUsage = MaxServerData / 2 local DaysUntilMaxUsage = MaxUsage / MinigamesStorageCostPerDay print ( DaysUntilMaxUsage ) -->> 141.35... Info This is just one example of what one can do with large data. The possibilities are down to your imagination.","title":"Storage limitations"},{"location":"introduction/#accessing-deeply-nested-keys","text":"Being able to access a deeply-nested key can be helpful for a few reasons: It can save on HttpService budget and lowers the amount of downloaded data Saves unnecessary lines of code rooting through tables Gruesome sanity checks are a thing of the past! Making a request to a key using ::GetAsync() will always return profound information: (success: boolean, value: string | table) Success is either true or false - if the information was retrieved or sent successfully. Value will be the response body with a successful request or the whole response dictionary if it fails.","title":"Accessing deeply-nested keys"},{"location":"introduction/#extending-robase-and-managing-your-data","text":"Writing your own manager similar to DataStore2 or ProfileService may seem daunting at first, but as long as you are safe and secure when handling your data, it does not need to be as developed and can simply be a primitive version of them, but take note: Key Information Cache is a necessity; Session-Locking is recommended; You should write parsers to form keys to access data when needed; Downloading the whole database for each server is cumbersome and can lead to eating through your data usage, only access data thats needed, de-serialise your data appropriately; Check out the source code for insight into how the code works!","title":"Extending Robase and managing your data"},{"location":"introduction/#why-promises","text":"Quote The way Roblox models asynchronous operations by default is by yielding (stopping) the thread and then resuming it when the future value is available. This model is not ideal because: Functions you call can yield without warning, or only yield sometimes, leading to unpredictable and surprising results. Accidentally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into. It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery. When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful. Yielding lacks easy access to introspection and the ability to cancel an operation if the value is no longer needed. Source: why you should use promises","title":"Why Promises?"},{"location":"introduction/#dynamic-updates","text":"Every key in your Firebase Realtime Database can be modified from the Firebase Console. This allows for some unique behaviour that you couldn't otherwise do without loading up the client and entering the game yourself to modify DataStores through the command line - which is slow, and can be complicated. With a Realtime Database you can have functions that check keys periodically or do something at specific times, or enable/disable beta features/content for your players depending on the value received. As noted in our example, Double XP is a perfect example of a timed event that can run via your database. You can set a key, say \"Activate\" to true, and then watch as your game-code updates and displays that the event is in progress and updates accordingly. You can have Fast Flags for your game, this is the deployment system Roblox uses to enable and disable content, it's also why bugs can just appear out of nowhere sometime.","title":"Dynamic Updates"},{"location":"Guide/examples/","text":"Examples Warning This page is still in the process of being documented. Saving data Saving data is straight forward with Robase. :SetAsync() will default to using a PUT request if one is not provided. 1 2 3 4 local PlayerRobase = RobaseService : GetRobase ( \"Players\" ) -- Key is where you store player data, not necessarily (root) or \"\" local PlayerData = { --[[ Some Data Here ]] } local Success , Result = PlayerRobase : SetAsync ( \"PlayerUserId\" , PlayerData ) Loading data Loading data is also really simple, similar to DataStoreService, we do: 1 2 3 local PlayerRobase = RobaseService : GetRobase ( \"Players\" ) local Success , Result = PlayerRobase : GetAsync ( \"PlayerUserId\" ) local Data = ( Success and Result ~= nil ) and Result Updating data Updating with Robase is just like DataStoreService, you provide a key, a transform function for the data, and bada-bing bada-boom your code updates. However, Robase has one key advantage: Batch Updating. This is useful if you have a list of keys to update together. Updating a single Dictionary This is going to be your de-facto saving method, just like DataStoreService this is method you use when changing data. It's most useful when updating a single player, for example. 1 2 3 4 5 6 7 8 9 10 11 12 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local NewData = { Level = 10 , Coins = 100 } local Callback = function ( oldData ) return NewData . Level > oldData . Level and newData or oldData end local Success , Result = PlayersRobase : UpdateAsync ( \"PlayerUserId\" , Callback ) Batch Updating a list of Dictionaries Okay, so what's this fancy batch updating? It's simple! Lets say you have some server data and some player data that you wish to save, you could do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 local GlobalRobase = RobaseService : GetRobase ( \"\" ) local UpdatedCache = { Players = { Player1 = { Level = 20 , Coins = 2345 , }, Player2 = { Level = 2 , Coins = 10 , } }, Server = { LastUpdatedAt = os.date () } } local Callbacks = { Players = function ( oldPlayersData ) return Cache . Players end , Server = function ( oldServerData ) return Cache . Server end } local Success , Result = GlobalRobase : BatchUpdateAsync ( \"\" , Callbacks ) What if we want to award every active player with free levels, almost instantly? 1 2 3 4 5 6 7 8 9 10 11 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local Callbacks = { } for _ , player in pairs ( game . Players : GetPlayers ()) do -- Populate Callbacks Callbacks [ player . UserId ] = function ( oldData ) return oldData . Level + 5 end end local Success , Result = PlayersRobase : BatchUpdateAsync ( \"\" , Callbacks ) Note This sort of functionality would probably be best used for events, where you can wait for some value to get toggled and then this code would run. Deleting data There are only a few edge cases where deleting data from the Realtime Database is down to the end-user or client, one scenario in particular is allowing player's to wipe their data and restart anew. 1 2 3 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local Success , Result = PlayersRobase : DeleteAsync ( \"SomeUserId\" )","title":"Robase Examples"},{"location":"Guide/examples/#examples","text":"Warning This page is still in the process of being documented.","title":"Examples"},{"location":"Guide/examples/#saving-data","text":"Saving data is straight forward with Robase. :SetAsync() will default to using a PUT request if one is not provided. 1 2 3 4 local PlayerRobase = RobaseService : GetRobase ( \"Players\" ) -- Key is where you store player data, not necessarily (root) or \"\" local PlayerData = { --[[ Some Data Here ]] } local Success , Result = PlayerRobase : SetAsync ( \"PlayerUserId\" , PlayerData )","title":"Saving data"},{"location":"Guide/examples/#loading-data","text":"Loading data is also really simple, similar to DataStoreService, we do: 1 2 3 local PlayerRobase = RobaseService : GetRobase ( \"Players\" ) local Success , Result = PlayerRobase : GetAsync ( \"PlayerUserId\" ) local Data = ( Success and Result ~= nil ) and Result","title":"Loading data"},{"location":"Guide/examples/#updating-data","text":"Updating with Robase is just like DataStoreService, you provide a key, a transform function for the data, and bada-bing bada-boom your code updates. However, Robase has one key advantage: Batch Updating. This is useful if you have a list of keys to update together.","title":"Updating data"},{"location":"Guide/examples/#updating-a-single-dictionary","text":"This is going to be your de-facto saving method, just like DataStoreService this is method you use when changing data. It's most useful when updating a single player, for example. 1 2 3 4 5 6 7 8 9 10 11 12 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local NewData = { Level = 10 , Coins = 100 } local Callback = function ( oldData ) return NewData . Level > oldData . Level and newData or oldData end local Success , Result = PlayersRobase : UpdateAsync ( \"PlayerUserId\" , Callback )","title":"Updating a single Dictionary"},{"location":"Guide/examples/#batch-updating-a-list-of-dictionaries","text":"Okay, so what's this fancy batch updating? It's simple! Lets say you have some server data and some player data that you wish to save, you could do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 local GlobalRobase = RobaseService : GetRobase ( \"\" ) local UpdatedCache = { Players = { Player1 = { Level = 20 , Coins = 2345 , }, Player2 = { Level = 2 , Coins = 10 , } }, Server = { LastUpdatedAt = os.date () } } local Callbacks = { Players = function ( oldPlayersData ) return Cache . Players end , Server = function ( oldServerData ) return Cache . Server end } local Success , Result = GlobalRobase : BatchUpdateAsync ( \"\" , Callbacks ) What if we want to award every active player with free levels, almost instantly? 1 2 3 4 5 6 7 8 9 10 11 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local Callbacks = { } for _ , player in pairs ( game . Players : GetPlayers ()) do -- Populate Callbacks Callbacks [ player . UserId ] = function ( oldData ) return oldData . Level + 5 end end local Success , Result = PlayersRobase : BatchUpdateAsync ( \"\" , Callbacks ) Note This sort of functionality would probably be best used for events, where you can wait for some value to get toggled and then this code would run.","title":"Batch Updating a list of Dictionaries"},{"location":"Guide/examples/#deleting-data","text":"There are only a few edge cases where deleting data from the Realtime Database is down to the end-user or client, one scenario in particular is allowing player's to wipe their data and restart anew. 1 2 3 local PlayersRobase = RobaseService : GetRobase ( \"Players\" ) local Success , Result = PlayersRobase : DeleteAsync ( \"SomeUserId\" )","title":"Deleting data"},{"location":"Guide/installation/","text":"Installation There are two methods to get up and running with Robase. For our examples, we will install RobaseService into ReplicatedStorage . Note, it's okay to install RobaseService wherever you want. Method A: Roblox Model (via Roblox Studio) Caution Roblox Models can be outdated, the suggested installation method is Method B. Todo Write documentation for Roblox Model. Method B: Filesystem (via Rojo) Go to the Github Releases and download the latest stable release of RobaseService. Save it somewhere meaningful so you only need to download it once. Open your working directory in your preferred IDE and sync your files with an empty studio using Rojo ! Copy the source wherever you wish, ReplicatedStorage is recommended. Continue developing!","title":"Installing Robase"},{"location":"Guide/installation/#installation","text":"There are two methods to get up and running with Robase. For our examples, we will install RobaseService into ReplicatedStorage . Note, it's okay to install RobaseService wherever you want.","title":"Installation"},{"location":"Guide/installation/#method-a-roblox-model-via-roblox-studio","text":"Caution Roblox Models can be outdated, the suggested installation method is Method B. Todo Write documentation for Roblox Model.","title":"Method A: Roblox Model (via Roblox Studio)"},{"location":"Guide/installation/#method-b-filesystem-via-rojo","text":"Go to the Github Releases and download the latest stable release of RobaseService. Save it somewhere meaningful so you only need to download it once. Open your working directory in your preferred IDE and sync your files with an empty studio using Rojo ! Copy the source wherever you wish, ReplicatedStorage is recommended. Continue developing!","title":"Method B: Filesystem (via Rojo)"},{"location":"Guide/setup/","text":"Setting up Robase Warning This page is still in the process of being documented. RobaseService is made to be a replication of DataStoreService so that setup and transferring data is simple to do. Setup Example Code that once looked like this: local DataStoreService = game : GetService ( \"DataStoreService\" ) local ExampleDataStore = DataStoreService : GetDataStore ( \"Example\" ) local ExampleData = ExampleDataStore : GetAsync ( \"123456789\" ) Will now look like this: local RobaseServiceModule = require ( path . to . robase ) local RobaseService = RobaseServiceModule . new ( \"URL\" , \"AUTH\" ) local ExampleRobase = RobaseService : GetRobase ( \"NAME\" ) local Success , Result = ExampleRobase : GetAsync ( \"KEY\" ) Every method call to a Robase will return a Success and a Result , check the API Reference for more detail information. Transferring from DataStoreService The following is relevant code to transfer player data from DataStoreService to RobaseService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local DataStoreName = \"Enter DataStore Name\" local FirebaseAuthKey = \"Enter Firebase Auth Key\" local FirebaseDBUrl = \"Enter Firebase DB Url\" local RobaseName = \"Enter Robase Name\" local DataStoreService = game : GetService ( \"DataStoreService\" ) local RobaseServiceModule = require ( \"path.to.robase\" ) local RobaseService = RobaseServiceModule . new ( FirebaseDBUrl , FirebaseAuthKey ) local GlobalDataStore = game : GetDataStore ( DataStoreName ) local GlobalRobase = RobaseService : GetRobase ( RobaseName ) game : GetService ( \"Players\" ). PlayerAdded : Connect ( function ( player ) local DS_Key = string.format ( \"%d\" , player . UserId ) -- replace with DataStore key format, for example: string.format(\"Players/%d\", player.UserId) local RobaseKey = string.format ( \"%d\" , player . UserId ) -- replace with Robase key format for example: string.format(\"Players/%d\", player.UserId) local ExistsInRobase , Result = GlobalRobase : GetAsync ( RobaseKey ) local SavedData = GlobalDataStore : GetAsync ( DS_Key ) or nil if not ExistsInRobase and SavedData then -- Key does not exist in the Firebase and data was found in the DataStore -- so we save it ExistsInRobase , Result = GlobalRobase : SetAsync ( RobaseKey , SavedData , \"POST\" ) --[[if ExistsInRobase then -- perform sanity checks however you wish end]] end end )","title":"Setting up Robase"},{"location":"Guide/setup/#setting-up-robase","text":"Warning This page is still in the process of being documented. RobaseService is made to be a replication of DataStoreService so that setup and transferring data is simple to do.","title":"Setting up Robase"},{"location":"Guide/setup/#setup-example","text":"Code that once looked like this: local DataStoreService = game : GetService ( \"DataStoreService\" ) local ExampleDataStore = DataStoreService : GetDataStore ( \"Example\" ) local ExampleData = ExampleDataStore : GetAsync ( \"123456789\" ) Will now look like this: local RobaseServiceModule = require ( path . to . robase ) local RobaseService = RobaseServiceModule . new ( \"URL\" , \"AUTH\" ) local ExampleRobase = RobaseService : GetRobase ( \"NAME\" ) local Success , Result = ExampleRobase : GetAsync ( \"KEY\" ) Every method call to a Robase will return a Success and a Result , check the API Reference for more detail information.","title":"Setup Example"},{"location":"Guide/setup/#transferring-from-datastoreservice","text":"The following is relevant code to transfer player data from DataStoreService to RobaseService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 local DataStoreName = \"Enter DataStore Name\" local FirebaseAuthKey = \"Enter Firebase Auth Key\" local FirebaseDBUrl = \"Enter Firebase DB Url\" local RobaseName = \"Enter Robase Name\" local DataStoreService = game : GetService ( \"DataStoreService\" ) local RobaseServiceModule = require ( \"path.to.robase\" ) local RobaseService = RobaseServiceModule . new ( FirebaseDBUrl , FirebaseAuthKey ) local GlobalDataStore = game : GetDataStore ( DataStoreName ) local GlobalRobase = RobaseService : GetRobase ( RobaseName ) game : GetService ( \"Players\" ). PlayerAdded : Connect ( function ( player ) local DS_Key = string.format ( \"%d\" , player . UserId ) -- replace with DataStore key format, for example: string.format(\"Players/%d\", player.UserId) local RobaseKey = string.format ( \"%d\" , player . UserId ) -- replace with Robase key format for example: string.format(\"Players/%d\", player.UserId) local ExistsInRobase , Result = GlobalRobase : GetAsync ( RobaseKey ) local SavedData = GlobalDataStore : GetAsync ( DS_Key ) or nil if not ExistsInRobase and SavedData then -- Key does not exist in the Firebase and data was found in the DataStore -- so we save it ExistsInRobase , Result = GlobalRobase : SetAsync ( RobaseKey , SavedData , \"POST\" ) --[[if ExistsInRobase then -- perform sanity checks however you wish end]] end end )","title":"Transferring from DataStoreService"}]}